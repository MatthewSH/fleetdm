package notarize

import (
	"fmt"

	"github.com/hashicorp/go-multierror"
)

// Error is the error structure generated by the notarization tool.
type Error struct {
	Code     int64             `plist:"code"`
	Message  string            `plist:"message"`
	UserInfo map[string]string `plist:"userInfo"`
}

// Errors is a list of error and also implements error.
type Errors []Error

// Error implements error
func (err Error) Error() string {
	return fmt.Sprintf("%s (%d)", err.Message, err.Code)
}

// Error implements error
func (err Errors) Error() string {
	if len(err) == 0 {
		return "no errors"
	}

	var result error
	for _, e := range err {
		result = multierror.Append(result, e)
	}

	return result.Error()
}

// ContainsCode returns true if the errors list has an error with the given code.
func (err Errors) ContainsCode(code int64) bool {
	for _, e := range err {
		if e.Code == code {
			return true
		}
	}

	return false
}

// IsNetworkError checks if an error is a network-related error that should be retried.
// This includes both structured errors with specific codes and unstructured error messages
// from xcrun notarytool that contain network error codes.
func IsNetworkError(err error) bool {
	if err == nil {
		return false
	}

	// Check if it's a structured Errors type with known network error codes
	if e, ok := err.(Errors); ok {
		// -19000: Network became unavailable
		if e.ContainsCode(-19000) {
			return true
		}
	}

	// Check the error message for common NSURLErrorDomain network error codes
	errMsg := err.Error()
	networkErrorCodes := []string{
		"Code=-1009", // The Internet connection appears to be offline
		"Code=-1001", // The request timed out
		"Code=-1004", // Could not connect to the server
		"Code=-1005", // The network connection was lost
		"Code=-1006", // Could not resolve host
		"Code=-1200", // Secure connection failed
		"Code=-1201", // Server certificate validation failed
	}

	for _, code := range networkErrorCodes {
		if contains(errMsg, code) {
			return true
		}
	}

	return false
}

// contains checks if a string contains a substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		indexString(s, substr) >= 0)
}

// indexString returns the index of the first instance of substr in s, or -1 if not present
func indexString(s, substr string) int {
	n := len(substr)
	if n == 0 {
		return 0
	}
	for i := 0; i+n <= len(s); i++ {
		if s[i:i+n] == substr {
			return i
		}
	}
	return -1
}
